# AI 에이전트 행동 지침

이 프로젝트에서 AI 에이전트(Cursor, Claude 등)가 따라야 할 행동 규칙입니다.

---

## 핵심 원칙

이 프로젝트의 모든 규칙은 아래 3가지 원칙 위에 세워진다.

### 1. 문서가 기준이다 (Document-Driven)

개인의 기억이나 판단이 아니라, **문서에 적힌 내용이 유일한 기준**이다.

- "이렇게 하기로 했었다" → 문서에 없으면 합의되지 않은 것이다
- "당연히 이렇게 해야 한다" → 문서에 없으면 개인 의견일 뿐이다
- 코드와 문서가 충돌하면 → 문서를 먼저 확인하고, 문서가 맞으면 코드를 수정한다

### 2. 사람이 기억하지 않는다 (Automate Enforcement)

규칙을 사람이 매번 기억하고 지키는 것에 의존하지 않는다. **체크리스트와 CI가 자동 검사**한다.

- 커밋 → CI가 린트, 테스트, 커밋 메시지 형식을 자동 검증
- PR → 체크리스트 템플릿이 필수 항목을 강제
- 배포 → CI 파이프라인이 테스트 통과 없이 배포를 차단

### 3. 누가 해도 같은 품질이 나온다 (Consistent Quality)

실력 좋은 사람이 있을 때만 잘 되는 구조는 불안정하다. **누가 작업해도 일정 품질이 보장**되는 구조를 만든다.

- 템플릿 → 문서 형식이 통일된다
- Cursor Rules → AI가 매번 같은 패턴으로 코드를 생성한다
- 검증 프로토콜 → 빠뜨리는 항목 없이 체크한다
- CI 자동화 → 사람의 실수를 기계가 잡는다

---

## 작업 시작 프로토콜

### 새 서비스 작업 시

1. 해당 서비스의 `docs/{service}/CONTEXT.md`를 먼저 읽는다
2. 현재 작업 버전을 확인한다
3. 해당 버전의 문서 5종을 파악한다

### 기능 개발 요청 시

1. `CONTEXT.md`에서 해당 기능의 진행 상태와 **도메인 배정**을 확인한다
2. `03-api-contract.md`의 **상태가 Locked**인지 확인한다 — Draft/Review면 구현을 시작하지 않는다
3. `01-requirements.md`에서 기능 요구사항(F-ID)을 확인한다
4. `02-screen-spec.md`에서 관련 화면(S-ID)과 UI 패턴(모달/페이지/패널 등)을 확인한다
5. `03-api-contract.md`에서 해당 도메인의 인터페이스 계약(타입, 에러 코드)을 확인한다
6. `05-api-spec.md`에서 API 상세 스펙을 확인한다
7. `08-implementation-guide.md`에서 구현 패턴과 주의사항을 확인한다
8. 기존 코드가 있으면 `apps/{service}/`를 확인한다
9. 요구사항(F-ID) ↔ 화면(S-ID) ↔ 계약(03) ↔ API(05) 간 교차 참조가 일치하는지 확인한 후 구현을 시작한다

### 버그 수정 요청 시

1. 관련 서비스의 `CONTEXT.md`를 확인한다
2. `09-test-cases.md`에서 관련 테스트 케이스를 확인한다
3. 기존 코드에서 원인을 분석한다
4. 수정 후 테스트 케이스 통과를 확인한다

---

## 문서 변환 프로토콜

### PM 기획서 PPT 변환 시

1. `.cursor/rules/doc-conversion.mdc` 규칙을 따른다
2. `docs/_templates/` 폴더의 템플릿을 기반으로 작성한다
3. 변환 결과를 `docs/{service}/{version}/`에 저장한다
4. `03-api-contract.md`는 **Draft** 상태로 생성한다
5. `CONTEXT.md`를 업데이트한다 (도메인 배정 포함)
6. `docs/overview.md`에 서비스가 없으면 추가한다
7. 팀이 `03-api-contract.md`를 리뷰하고 **Locked**로 전환한 후 구현을 시작한다

---

## 코드 작성 규칙

### 언어 규칙

- 코드 주석: 영문
- 변수/함수명: 영문
- 문서: 한국어 (이 프로젝트의 개발 문서는 한국어)
- 커밋 메시지: 영문, 아래 커밋 컨벤션 참조

### 구현 순서

기능 구현 시 다음 순서를 따른다. **각 단계마다 실행하여 동작을 확인한 후** 다음 단계로 넘어간다.

1. **모델 정의** - 데이터 모델, 스키마 → 마이그레이션 실행하여 반영 확인
2. **도메인 로직** - 비즈니스 규칙 구현 → 단위 테스트 작성 및 실행
3. **인프라 레이어** - DB, 외부 API 연동 → 실제 데이터 조회로 연동 확인
4. **API 레이어** - 엔드포인트 정의 → 실제 요청으로 응답 확인
5. **통합 테스트** - 전체 플로우 테스트 실행

### 구현 중 디버깅 원칙

> **"추측하지 말고 측정하라."** — 실제 데이터를 확인하는 데 5분을 투자하면, 반복 수정에 들일 30분을 아낄 수 있다.

| 원칙 | 행동 |
|------|------|
| **데이터 먼저 확인** | 디버깅 시작 시 반드시 실제 DB 값을 `SELECT`로 조회하거나, `fmt.Printf` / `console.log`로 raw 값을 출력한 뒤 수정에 착수한다 |
| **변경 전 영향 분석** | 타입, 인터페이스, 상수 변경 시 `grep` / 검색으로 해당 심볼을 사용하는 **모든 파일을 먼저 파악**한 뒤 수정한다 |
| **테스트 환경 ≠ 실환경** | 인메모리 DB(`SQLite :memory:` 등)와 파일/서버 DB의 동작 차이를 인지한다. 가능하면 실제 DB 환경으로 테스트한다 |
| **반복 수정 임계치** | 같은 파일을 **3회 이상 수정**하게 되면, 부분 패치 대신 파일 전체를 재작성하여 일관성을 확보한다 |
| **중간 검증 루프** | 코드를 작성하면서 중간중간 실행하여 동작을 확인한다. 한 번에 많은 코드를 작성한 뒤 나중에 몰아서 테스트하지 않는다 |

### TBD(미결 사항) 처리 정책

문서에 TBD로 표시된 기능을 코드에서 처리할 때 다음 3단계 중 하나를 선택한다.

| 단계 | 이름 | 처리 방식 | 적용 기준 |
|------|------|----------|----------|
| Level 1 | **Block** | UI/API에서 해당 기능을 숨기거나 비활성화 | 미구현 기능을 사용자가 접근할 수 없어야 할 때 |
| Level 2 | **Degrade** | 축소된 기능으로 동작 + 사용자에게 제한 안내 | 부분적으로 동작하며 사용자가 인지해야 할 때 |
| Level 3 | **Stub** | 인터페이스만 정의, 내부 미구현 (개발 전용) | 아키텍처 확장성 확보가 목적일 때 |

**선택 기준:**
1. 사용자가 해당 기능에 접근 가능한가? → **YES**: Block (UI 숨김/비활성화)
2. 부분 동작이 가능하고 안내할 수 있는가? → **YES**: Degrade (축소 + 안내)
3. 그 외 → **Stub** (인터페이스만)

**금지**: 기능을 활성화 상태로 두고 런타임 에러로 막는 방식 (사용자 혼란 유발)

### 코드 품질

- 타입 힌트 필수 (Python: type hints, TypeScript: strict mode)
- 에러 처리: 도메인 예외를 정의하고 API 레이어에서 변환
- 로깅: 구조화된 로그 (structlog 등) 사용, 아래 로깅 가이드라인 준수

### 로깅 가이드라인

| 레벨 | 사용 기준 | 예시 |
|------|----------|------|
| **ERROR** | 요청 처리 실패, 복구 불가능한 상황 | DB 연결 실패, 외부 API 타임아웃 |
| **WARN** | 예상 밖이지만 계속 동작 가능한 상황 | 재시도 발생, 폴백 사용, 삭제 실패(재시도 예정) |
| **INFO** | 정상 동작의 주요 이벤트 | 요청 시작/완료, 배치 처리 결과, 상태 변경 |
| **DEBUG** | 개발/디버깅용 상세 정보 | 쿼리 파라미터, 중간 계산 결과 |

**필수 규칙:**
- 반복 실행(폴링, 배치, 스케줄)에는 사이클당 최소 1건의 INFO 로그를 남긴다
- "아무 일도 안 일어나는" 상황(대상 0건, 전부 스킵)에도 INFO 로그를 남긴다 (무반응 방지)
- 에러 로그에는 복구 방법 또는 다음 행동을 함께 기록한다

---

## 문서 유지보수 규칙

### 코드 변경 시 문서 업데이트

- 새 기능 추가 → `01-requirements.md`, `05-api-spec.md` 업데이트
- API 변경 → `05-api-spec.md` 업데이트, `03-api-contract.md`와 불일치 여부 확인
- 인터페이스/타입 변경 → `03-api-contract.md` 변경 요청(CR) 절차 진행
- 테스트 추가 → `09-test-cases.md` 업데이트
- 아키텍처 변경 → `08-implementation-guide.md` 업데이트
- 진행 상태 변경 → `CONTEXT.md` 체크리스트 + 도메인 상태 업데이트

### 버전 업 시

#### 버전 번호 규칙 (Semantic Versioning)

`v{MAJOR}.{MINOR}.{PATCH}` 형식을 따른다.

| 변경 유형 | 버전 증가 | 예시 | 기준 |
|----------|----------|------|------|
| **호환 불가 변경** | MAJOR | v0.0.1 → v1.0.0 | API 계약 변경, DB 스키마 비호환 마이그레이션, 핵심 도메인 재설계 |
| **기능 추가** | MINOR | v1.0.0 → v1.1.0 | 새 기능(F-ID) 추가, 새 API 엔드포인트, 기존 기능 확장 |
| **버그 수정/개선** | PATCH | v1.1.0 → v1.1.1 | 버그 수정, 성능 개선, 문서 정정 (기능 변경 없음) |

> 초기 개발 단계(v0.x.x)에서는 MINOR 변경에도 호환 불가 변경이 포함될 수 있다.
> v1.0.0 이전까지는 실질적으로 MINOR를 기능 단위 마일스톤으로 사용한다.

#### 버전 업 절차

1. 새 버전 폴더 생성: `docs/{service}/{new-version}/`
2. 이전 버전 문서를 복사하여 변경분만 수정
3. `03-api-contract.md`가 있으면 상태를 **Draft**로 초기화 (새 버전의 계약은 재합의 필요)
4. `CONTEXT.md`의 현재 작업 버전을 업데이트
5. `docs/overview.md`의 버전 정보를 업데이트

#### 이전 버전 보존 정책

| 정책 | 내용 |
|------|------|
| **보존** | 이전 버전 폴더(`docs/{service}/v0.0.1/`)는 삭제하지 않고 유지한다 |
| **읽기 전용** | 이전 버전 문서는 수정하지 않는다 (변경 이력 보존) |
| **아카이브** | 2개 버전 이상 지난 문서는 필요 시 `docs/{service}/_archive/`로 이동 가능 |
| **참조** | 현재 버전 문서에서 이전 버전의 변경 사유를 간단히 기록한다 (변경 이력 테이블) |

---

## 구현 검증 프로토콜

기능 구현 후, PR 전, 코드 리뷰 시 아래 검증을 수행한다.

### 검증 항목

| # | 검증 대상 | 확인 내용 | 참조 문서 |
|---|----------|----------|----------|
| 1 | 기능-코드 매칭 | 구현한 기능이 `01-requirements.md`의 F-ID와 1:1 대응되는가 | `01-requirements.md` |
| 2 | API 스펙 일치 | 실제 엔드포인트(경로, 메서드, 요청/응답)가 `05-api-spec.md`와 일치하는가 | `05-api-spec.md` |
| 3 | 화면-코드 매칭 | UI 컴포넌트가 `02-screen-spec.md`의 S-ID, 상태관리, 인터랙션과 일치하는가 | `02-screen-spec.md` |
| 4 | 테스트 커버리지 | `09-test-cases.md`의 TC-ID에 대응하는 테스트 파일이 존재하는가 | `09-test-cases.md` |
| 5 | 구현 가이드 준수 | 코딩 컨벤션, 레이어 구조, 에러 처리 패턴이 `08-implementation-guide.md`를 따르는가 | `08-implementation-guide.md` |
| 6 | FE-BE 검증 일관성 | 동일한 비즈니스 규칙에 대해 프론트엔드/백엔드 양쪽의 검증 로직이 일치하는가 (필수값, 길이 제한, 형식 등) | `05-api-spec.md`, `02-screen-spec.md` |
| 7 | CONTEXT.md 정확성 | 진행 상태 체크리스트가 실제 구현 상태를 반영하는가 | `CONTEXT.md` |

### 검증 절차

1. 위 테이블을 순서대로 점검한다
2. 각 항목에 대해 PASS / FAIL 판정한다
3. 결과를 아래 형식으로 보고한다:

```
## 검증 결과

| # | 항목 | 상태 | 이슈 |
|---|------|------|------|
| 1 | 기능-코드 매칭 | PASS | - |
| 2 | API 스펙 일치 | FAIL | POST /api/v1/users 응답에 createdAt 필드 누락 |
| ... | ... | ... | ... |

**총 이슈: N개**
```

### 이슈 발견 시 행동

1. 각 이슈에 대해 수정 방법을 코드 예시와 함께 제시한다
2. 사용자에게 수정 적용 여부를 확인한다 (전체 수정 / 개별 수정 / 건너뛰기)
3. 수정 적용 후 해당 항목만 재검증한다
4. 재검증에서도 FAIL이면 수동 확인이 필요하다고 안내한다

### 보안 검증

기능 구현 시 아래 보안 항목을 추가로 점검한다.

| # | 영역 | 확인 내용 | 해당 시 조치 |
|---|------|----------|------------|
| S1 | **인증** | 인증이 필요한 엔드포인트에 미들웨어/가드가 적용되어 있는가 | 미적용 엔드포인트에 인증 추가 |
| S2 | **인가** | 역할/권한 체크가 비즈니스 로직이 아닌 API 레이어에서 수행되는가 | 권한 검사 위치 이동 |
| S3 | **입력 검증** | 사용자 입력이 서버 측에서 검증되는가 (길이, 형식, 범위) | 서버 측 검증 로직 추가 |
| S4 | **SQL Injection** | ORM/파라미터 바인딩을 사용하고 있는가 (raw query 금지) | raw query를 파라미터 바인딩으로 교체 |
| S5 | **XSS** | 사용자 입력이 HTML에 렌더링될 때 이스케이프 처리되는가 | 이스케이프/새니타이즈 적용 |
| S6 | **민감 데이터** | 비밀번호, 토큰, 개인정보가 로그/응답에 노출되지 않는가 | 마스킹 처리 또는 로그 제거 |
| S7 | **Rate Limiting** | 공개 엔드포인트(로그인, 회원가입 등)에 요청 제한이 있는가 | Rate limiter 미들웨어 추가 |
| S8 | **CORS** | 허용 오리진이 명시적으로 설정되어 있는가 (`*` 금지) | 화이트리스트 방식으로 변경 |
| S9 | **의존성** | 알려진 취약점이 있는 패키지를 사용하고 있지 않은가 | 패키지 업데이트 또는 대체 |

**보안 검증 시점:**
- 새 API 엔드포인트 추가 시: S1 ~ S4 필수
- UI에서 사용자 입력을 받는 기능: S3, S5 필수
- 로그인/인증 관련 기능: S1, S2, S6, S7 필수
- 배포 전 최종 점검: 전체 항목

### 자기 검증 한계 인식

AI가 자기 코드를 검증할 때 아래 한계가 있음을 인지하고 대응한다:

| 한계 | 대응 방식 |
|------|----------|
| 자기가 작성한 코드의 오류를 발견하기 어려움 | 사용자에게 핵심 비즈니스 로직의 수동 확인을 요청한다 |
| 동시성/레이스 컨디션은 정적 분석으로 탐지 불가 | 동시성이 관련된 기능은 반드시 사용자에게 별도 테스트를 권고한다 |
| "원래 의도"와 "실제 동작"의 괴리를 인식하지 못함 | 검증 시 문서에 적힌 기대 동작과 코드를 대조하되, 전수 검증은 사람이 확인한다고 명시한다 |

**규칙**: 검증 결과가 전부 PASS여도 "AI 자기 검증 결과이므로 핵심 로직은 사용자 확인 권장"이라는 면책 문구를 검증 보고서에 포함한다

---

## 변경사항 추적 및 문서 동기화 프로토콜

코드 변경 후 문서와의 불일치(드리프트)를 감지하고 동기화한다.

### 코드 → 문서 영향 매핑

코드 변경 위치에 따라 확인해야 할 문서가 달라진다:

| 변경된 코드 위치 | 확인 대상 문서 | 확인 내용 |
|-----------------|--------------|----------|
| `src/api/` 또는 라우터 | `05-api-spec.md` | 엔드포인트 추가/변경/삭제 반영 |
| `src/domain/` 또는 비즈니스 로직 | `01-requirements.md`, `08-implementation-guide.md` | 기능 정의, 도메인 규칙 변경 반영 |
| `src/models/` 또는 스키마 | `05-api-spec.md` (데이터 모델), `08-implementation-guide.md` | 데이터 모델 변경 반영 |
| UI 컴포넌트 | `02-screen-spec.md` | 화면 구조, 상태관리 변경 반영 |
| 테스트 파일 | `09-test-cases.md` | 테스트 케이스 추가/변경 반영 |
| 설정/인프라 | `08-implementation-guide.md` | 기술 스택, 환경 설정 변경 반영 |

### 드리프트 유형

| 유형 | 설명 | 예시 |
|------|------|------|
| 커버리지 누락 | 코드에 있지만 문서에 없는 기능 | 새 API 엔드포인트가 `05-api-spec.md`에 미등록 |
| 유효하지 않은 참조 | 문서가 삭제/변경된 코드를 참조 | 문서의 함수명이 리팩토링 후 변경됨 |
| 오래된 값 | 문서의 설정값/타입명이 현재 코드와 불일치 | 문서에는 `UserDTO`이나 코드에서 `UserResponse`로 변경 |
| 누락된 교차 참조 | 새 기능의 F-ID가 다른 문서에서 참조되지 않음 | F005 추가했지만 `09-test-cases.md`에 TC-F005 없음 |

### 동기화 절차

1. 변경된 파일 목록을 위 매핑 테이블에 대조하여 영향받는 문서를 식별한다
2. 해당 문서를 읽고 드리프트 유형에 해당하는 불일치를 탐지한다
3. 발견된 드리프트를 보고한다:

```
## 문서 동기화 필요

| 문서 | 드리프트 유형 | 상세 |
|------|-------------|------|
| 05-api-spec.md | 커버리지 누락 | DELETE /api/v1/users/{id} 엔드포인트 미등록 |
| 09-test-cases.md | 누락된 교차 참조 | F003에 대한 TC 없음 |
```

4. 사용자 승인 후 문서를 업데이트한다
5. `CONTEXT.md`의 진행 상태도 함께 업데이트한다

---

## Cursor Rules 유지보수 프로토콜

`.cursor/rules/` 파일도 프로젝트 변화에 맞춰 유지한다.

### 유지보수 트리거

| 변경 사항 | 업데이트 대상 |
|----------|-------------|
| 새 서비스 추가 | `service-example-rules.mdc` 복사 → `{service}-rules.mdc` 생성 |
| 프로젝트 구조 변경 (폴더 추가/이동) | `project-conventions.mdc` 구조 트리 업데이트 |
| 문서 변환 프로세스 변경 | `doc-conversion.mdc` 업데이트 |
| 서비스 기술 스택/패턴 변경 | 해당 `{service}-rules.mdc` 업데이트 |
| 코딩 컨벤션 변경 | `project-conventions.mdc` 코딩 규칙 업데이트 |

### 유지보수 절차

1. 위 트리거에 해당하는 변경을 감지한다
2. 관련 `.mdc` 파일의 현재 내용과 변경사항을 비교한다
3. 불일치가 있으면 업데이트 제안을 사용자에게 보고한다
4. 승인 후 `.mdc` 파일을 수정한다

---

## 커밋 컨벤션

### 형식

```
<type>(<scope>): <subject>

[body]

[footer]
```

- **subject**: 영문, 소문자 시작, 마침표 없음, 50자 이내
- **body**: 선택사항, "왜(why)" 변경했는지 설명
- **footer**: 선택사항, 이슈 참조 (`Closes #123`)

### 타입

| 타입 | 용도 |
|------|------|
| `feat` | 새 기능 추가 |
| `fix` | 버그 수정 |
| `docs` | 문서 변경 (코드 변경 없음) |
| `refactor` | 기능 변경 없는 코드 리팩토링 |
| `test` | 테스트 추가/수정 |
| `chore` | 빌드, 설정, 의존성 변경 |
| `style` | 포매팅, 세미콜론 등 (코드 동작 변경 없음) |

### 스코프

서비스명 또는 모듈명을 사용한다: `feat(auth)`, `fix(payment)`, `docs(api-spec)`

### 예시

```
feat(auth): add JWT refresh token endpoint

Refresh tokens expire after 7 days. Access tokens are
rotated on each refresh request.

Closes #42
```

---

## 브랜치 전략

> 팀 합의에 따라 수정 가능. 아래는 초기 기본값.

### 브랜치 구조

| 브랜치 | 용도 | 보호 |
|--------|------|------|
| `main` | 프로덕션 배포 기준 | PR만 허용, 직접 push 금지 |
| `develop` | 개발 통합 브랜치 | PR만 허용 |
| `feature/{issue}-{description}` | 기능 개발 | develop에서 분기 |
| `fix/{issue}-{description}` | 버그 수정 | develop에서 분기 |
| `hotfix/{issue}-{description}` | 긴급 수정 | main에서 분기 |

### 브랜치 네이밍

```
feature/42-add-login-api
fix/57-token-expiry-bug
hotfix/63-payment-crash
```

---

## PR (Pull Request) 규칙

### PR 생성 전 체크리스트

PR을 올리기 전에 아래를 모두 확인한다:

- [ ] 구현 검증 프로토콜 실행 완료 (전항목 PASS)
- [ ] 문서 동기화 확인 완료 (드리프트 없음)
- [ ] 테스트 전체 통과
- [ ] `CONTEXT.md` 진행 상태 업데이트 완료

### PR 설명 형식

```markdown
## 변경 사항
- 무엇을 왜 변경했는지 요약 (1-3줄)

## 관련 문서
- 변경/추가된 문서 목록 (있으면)

## 테스트
- 실행한 테스트와 결과 요약

## 검증 결과
- 구현 검증 프로토콜 PASS/FAIL 요약 (이슈 있으면 상세)

## 스크린샷
- UI 변경이 있으면 첨부
```

### PR 크기 가이드

| 크기 | 변경 파일 수 | 권장 여부 |
|------|-------------|----------|
| Small | 1-5개 | 권장 |
| Medium | 6-15개 | 허용 (리뷰 부담 주의) |
| Large | 16개 이상 | 분할 권장 — 한 PR에 하나의 목적 |

### 코드 리뷰 규칙

> 팀 합의에 따라 수정 가능. 아래는 초기 기본값.

- 최소 1명의 승인(Approve) 필요
- AI 자기 검증만으로 머지하지 않는다 — 사람의 리뷰가 반드시 필요하다
- 리뷰어는 "동작 여부"보다 "의도 일치 여부"에 집중한다

---

## CI 자동화 가이드

> 핵심 원칙 2번 "사람이 기억하지 않는다"를 실현하는 구조.

### 기술 스택

| 영역 | 기술 | 버전 | 비고 |
|------|------|------|------|
| **Backend** | Python, FastAPI | 3.12+ | |
| **Database** | PostgreSQL | 15+ | |
| **Task Queue** | Celery + Redis | | |
| **Desktop** | Go | 1.25+ | 1.25.8 최신 패치 |
| **Desktop** | Wails | v2.11.0 | |
| **Frontend** | React | 19.x (19.2.4) | |
| **Frontend** | TypeScript | 5.9.x (5.9.3) | |
| **Frontend** | Vite | 7.x (7.3.1) | |
| **Runtime** | Node.js | 24.x (24.13.0) | LTS 기준 |
| **Package Manager** | pnpm | 10.x (10.28.2) | Frontend 패키지 관리 |
| **Reverse Proxy** | Nginx | | |
| **CI** | GitHub Actions | | |

### CI 파이프라인 필수 단계

PR이 올라오면 아래가 자동 실행되어야 한다. 하나라도 실패하면 머지를 차단한다.

| 단계 | 검사 내용 | Backend (Python) | Frontend (React/TS) |
|------|----------|-----------------|---------------------|
| 1. 린트 | 코드 스타일, 포매팅 | `ruff check .` | `eslint .` |
| 2. 포맷 검증 | 포매팅 일관성 | `ruff format --check .` | `prettier --check .` |
| 3. 타입 체크 | 타입 오류 | `mypy src/` | `tsc --noEmit` |
| 4. 단위 테스트 | 비즈니스 로직 검증 | `pytest tests/unit/` | `vitest run` |
| 5. 통합 테스트 | API/DB 연동 검증 | `pytest tests/integration/` | - |
| 6. 커밋 메시지 | 컨벤션 준수 여부 | `commitlint` | `commitlint` |
| 7. 빌드 | 빌드 성공 여부 | - | `vite build` |
| 8. 문서 검증 | F-ID 교차 참조 | `python tools/validate-docs.py` | - |

### Pre-commit 훅 (`.pre-commit-config.yaml`)

로컬에서 커밋 전에 자동 실행하여 CI 실패를 미리 방지한다.

| 훅 | 명령어 | 역할 |
|----|--------|------|
| ruff format | `ruff format` | Python 코드 자동 포매팅 |
| ruff check | `ruff check --fix` | Python 린트 + 자동 수정 |
| mypy | `mypy` | Python 타입 체크 |
| eslint | `eslint --fix` | TS/React 린트 + 자동 수정 |
| prettier | `prettier --write` | TS/CSS/JSON 자동 포매팅 |
| commitlint | `commitlint` | 커밋 메시지 컨벤션 검증 |

```bash
# 초기 설정
pip install pre-commit
pre-commit install
pre-commit install --hook-type commit-msg
```

### AI가 CI를 활용하는 방법

AI 에이전트는 다음 상황에서 CI 결과를 참조한다:

- PR 생성 후 CI 실패 → 실패 로그를 읽고 수정안을 제시한다
- 린트 에러 → `ruff check --fix` 또는 `eslint --fix`로 자동 수정 시도, 불가능한 것은 사용자에게 보고
- 테스트 실패 → 실패한 테스트 케이스와 `09-test-cases.md`를 대조하여 원인을 분석한다
- 문서 검증 실패 → `tools/validate-docs.py` 출력을 보고 교차 참조 불일치를 수정한다

---

## 금지 사항

- 문서 없이 코드부터 작성하지 않는다
- `08-implementation-guide.md`의 코딩 컨벤션을 무시하지 않는다
- 테스트 없이 기능을 완료 처리하지 않는다
- `CONTEXT.md`의 진행 상태를 업데이트하지 않고 넘어가지 않는다
- 검증 프로토콜을 건너뛰고 PR을 생성하지 않는다
- 코드 변경 후 문서 동기화 확인 없이 작업을 종료하지 않는다
- 에러 원인을 추측하여 코드를 수정하지 않는다 — 반드시 실제 값을 확인한 후 수정한다
- 타입/인터페이스 변경 시 영향 범위를 파악하지 않고 수정하지 않는다
